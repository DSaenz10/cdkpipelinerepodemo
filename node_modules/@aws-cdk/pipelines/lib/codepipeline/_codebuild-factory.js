"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stackVariableNamespace = exports.mergeBuildSpecs = exports.mergeCodeBuildOptions = exports.CodeBuildFactory = void 0;
const crypto = require("crypto");
const fs = require("fs");
const path = require("path");
const codebuild = require("@aws-cdk/aws-codebuild");
const codepipeline_actions = require("@aws-cdk/aws-codepipeline-actions");
const ec2 = require("@aws-cdk/aws-ec2");
const core_1 = require("@aws-cdk/core");
const constructs_1 = require("constructs");
const pipeline_queries_1 = require("../helpers-internal/pipeline-queries");
const construct_internals_1 = require("../private/construct-internals");
const javascript_1 = require("../private/javascript");
/**
 * Produce a CodeBuild project from a ShellStep and some CodeBuild-specific customizations
 *
 * The functionality here is shared between the `CodePipeline` translating a `ShellStep` into
 * a CodeBuild project, as well as the `CodeBuildStep` straight up.
 */
class CodeBuildFactory {
    constructor(constructId, props) {
        var _a;
        this.constructId = constructId;
        this.props = props;
        this.stepId = (_a = props.stepId) !== null && _a !== void 0 ? _a : constructId;
    }
    // eslint-disable-next-line max-len
    static fromShellStep(constructId, shellStep, additional) {
        return new CodeBuildFactory(constructId, {
            commands: shellStep.commands,
            env: shellStep.env,
            envFromCfnOutputs: shellStep.envFromCfnOutputs,
            inputs: shellStep.inputs,
            outputs: shellStep.outputs,
            stepId: shellStep.id,
            installCommands: shellStep.installCommands,
            ...additional,
        });
    }
    static fromCodeBuildStep(constructId, step, additional) {
        const factory = CodeBuildFactory.fromShellStep(constructId, step, {
            projectName: step.projectName,
            role: step.role,
            projectOptions: {
                buildEnvironment: step.buildEnvironment,
                rolePolicy: step.rolePolicyStatements,
                securityGroups: step.securityGroups,
                partialBuildSpec: step.partialBuildSpec,
                vpc: step.vpc,
                subnetSelection: step.subnetSelection,
                ...additional === null || additional === void 0 ? void 0 : additional.projectOptions,
            },
            ...additional,
        });
        return {
            produceAction: (stage, options) => {
                const result = factory.produceAction(stage, options);
                if (result.project) {
                    step._setProject(result.project);
                }
                return result;
            },
        };
    }
    get project() {
        if (!this._project) {
            throw new Error('Project becomes available after produce() has been called');
        }
        return this._project;
    }
    produceAction(stage, options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const projectOptions = mergeCodeBuildOptions(options.codeBuildDefaults, this.props.projectOptions);
        const inputs = (_a = this.props.inputs) !== null && _a !== void 0 ? _a : [];
        const outputs = (_b = this.props.outputs) !== null && _b !== void 0 ? _b : [];
        const mainInput = inputs.find(x => x.directory === '.');
        const extraInputs = inputs.filter(x => x.directory !== '.');
        const inputArtifact = mainInput
            ? options.artifacts.toCodePipeline(mainInput.fileSet)
            : options.fallbackArtifact;
        const extraInputArtifacts = extraInputs.map(x => options.artifacts.toCodePipeline(x.fileSet));
        const outputArtifacts = outputs.map(x => options.artifacts.toCodePipeline(x.fileSet));
        if (!inputArtifact) {
            // This should actually never happen because CodeBuild projects shouldn't be added before the
            // Source, which always produces at least an artifact.
            throw new Error(`CodeBuild action '${this.stepId}' requires an input (and the pipeline doesn't have a Source to fall back to). Add an input or a pipeline source.`);
        }
        const installCommands = [
            ...generateInputArtifactLinkCommands(options.artifacts, extraInputs),
            ...(_c = this.props.installCommands) !== null && _c !== void 0 ? _c : [],
        ];
        const buildSpecHere = codebuild.BuildSpec.fromObject({
            version: '0.2',
            phases: {
                install: ((_d = installCommands.length) !== null && _d !== void 0 ? _d : 0) > 0 ? { commands: installCommands } : undefined,
                build: this.props.commands.length > 0 ? { commands: this.props.commands } : undefined,
            },
            artifacts: javascript_1.noEmptyObject(renderArtifactsBuildSpec(options.artifacts, (_e = this.props.outputs) !== null && _e !== void 0 ? _e : [])),
        });
        // Partition environment variables into environment variables that can go on the project
        // and environment variables that MUST go in the pipeline (those that reference CodePipeline variables)
        const env = javascript_1.noUndefined((_f = this.props.env) !== null && _f !== void 0 ? _f : {});
        const [actionEnvs, projectEnvs] = javascript_1.partition(Object.entries(env !== null && env !== void 0 ? env : {}), ([, v]) => containsPipelineVariable(v));
        const environment = mergeBuildEnvironments((_g = projectOptions === null || projectOptions === void 0 ? void 0 : projectOptions.buildEnvironment) !== null && _g !== void 0 ? _g : {}, {
            environmentVariables: javascript_1.noEmptyObject(javascript_1.mapValues(javascript_1.mkdict(projectEnvs), value => ({ value }))),
        });
        const fullBuildSpec = (projectOptions === null || projectOptions === void 0 ? void 0 : projectOptions.partialBuildSpec) ? codebuild.mergeBuildSpecs(projectOptions.partialBuildSpec, buildSpecHere)
            : buildSpecHere;
        const osFromEnvironment = environment.buildImage && environment.buildImage instanceof codebuild.WindowsBuildImage
            ? ec2.OperatingSystemType.WINDOWS
            : ec2.OperatingSystemType.LINUX;
        const actualBuildSpec = filterBuildSpecCommands(fullBuildSpec, osFromEnvironment);
        const scope = (_h = this.props.scope) !== null && _h !== void 0 ? _h : options.scope;
        let projectBuildSpec;
        if (this.props.passBuildSpecViaCloudAssembly) {
            // Write to disk and replace with a reference
            const relativeSpecFile = `buildspec-${constructs_1.Node.of(scope).addr}-${this.constructId}.yaml`;
            const absSpecFile = path.join(construct_internals_1.cloudAssemblyBuildSpecDir(scope), relativeSpecFile);
            fs.writeFileSync(absSpecFile, core_1.Stack.of(scope).resolve(actualBuildSpec.toBuildSpec()), { encoding: 'utf-8' });
            projectBuildSpec = codebuild.BuildSpec.fromSourceFilename(relativeSpecFile);
        }
        else {
            projectBuildSpec = actualBuildSpec;
        }
        // A hash over the values that make the CodeBuild Project unique (and necessary
        // to restart the pipeline if one of them changes). projectName is not necessary to include
        // here because the pipeline will definitely restart if projectName changes.
        // (Resolve tokens)
        const projectConfigHash = hash(core_1.Stack.of(scope).resolve({
            environment: serializeBuildEnvironment(environment),
            buildSpecString: actualBuildSpec.toBuildSpec(),
        }));
        const actionName = (_j = options.actionName) !== null && _j !== void 0 ? _j : this.stepId;
        let projectScope = scope;
        if ((_k = this.props.additionalConstructLevel) !== null && _k !== void 0 ? _k : true) {
            projectScope = construct_internals_1.obtainScope(scope, actionName);
        }
        const project = new codebuild.PipelineProject(projectScope, this.constructId, {
            projectName: this.props.projectName,
            environment,
            vpc: projectOptions.vpc,
            subnetSelection: projectOptions.subnetSelection,
            securityGroups: projectOptions.securityGroups,
            buildSpec: projectBuildSpec,
            role: this.props.role,
        });
        if (this.props.additionalDependable) {
            project.node.addDependency(this.props.additionalDependable);
        }
        if (projectOptions.rolePolicy !== undefined) {
            projectOptions.rolePolicy.forEach(policyStatement => {
                project.addToRolePolicy(policyStatement);
            });
        }
        const queries = new pipeline_queries_1.PipelineQueries(options.pipeline);
        const stackOutputEnv = javascript_1.mapValues((_l = this.props.envFromCfnOutputs) !== null && _l !== void 0 ? _l : {}, outputRef => `#{${stackVariableNamespace(queries.producingStack(outputRef))}.${outputRef.outputName}}`);
        const configHashEnv = options.beforeSelfMutation
            ? { _PROJECT_CONFIG_HASH: projectConfigHash }
            : {};
        stage.addAction(new codepipeline_actions.CodeBuildAction({
            actionName: actionName,
            input: inputArtifact,
            extraInputs: extraInputArtifacts,
            outputs: outputArtifacts,
            project,
            runOrder: options.runOrder,
            // Inclusion of the hash here will lead to the pipeline structure for any changes
            // made the config of the underlying CodeBuild Project.
            // Hence, the pipeline will be restarted. This is necessary if the users
            // adds (for example) build or test commands to the buildspec.
            environmentVariables: javascript_1.noEmptyObject(cbEnv({
                ...javascript_1.mkdict(actionEnvs),
                ...configHashEnv,
                ...stackOutputEnv,
            })),
        }));
        this._project = project;
        return { runOrdersConsumed: 1, project };
    }
}
exports.CodeBuildFactory = CodeBuildFactory;
/**
 * Generate commands to move additional input artifacts into the right place
 */
function generateInputArtifactLinkCommands(artifacts, inputs) {
    return inputs.map(input => {
        const fragments = [];
        if (!['.', '..'].includes(path.dirname(input.directory))) {
            fragments.push(`mkdir -p "${input.directory}"`);
        }
        const artifact = artifacts.toCodePipeline(input.fileSet);
        fragments.push(`ln -s "$CODEBUILD_SRC_DIR_${artifact.artifactName}" "${input.directory}"`);
        return fragments.join(' && ');
    });
}
function renderArtifactsBuildSpec(artifactMap, outputs) {
    // save the generated files in the output artifact
    // This part of the buildspec has to look completely different depending on whether we're
    // using secondary artifacts or not.
    if (outputs.length === 0) {
        return {};
    }
    if (outputs.length === 1) {
        return {
            'base-directory': outputs[0].directory,
            'files': '**/*',
        };
    }
    const secondary = {};
    for (const output of outputs) {
        const art = artifactMap.toCodePipeline(output.fileSet);
        if (!art.artifactName) {
            throw new Error('You must give the output artifact a name');
        }
        secondary[art.artifactName] = {
            'base-directory': output.directory,
            'files': '**/*',
        };
    }
    return { 'secondary-artifacts': secondary };
}
function mergeCodeBuildOptions(...opts) {
    const xs = [{}, ...opts.filter(isDefined)];
    while (xs.length > 1) {
        const [a, b] = xs.splice(xs.length - 2, 2);
        xs.push(merge2(a, b));
    }
    return xs[0];
    function merge2(a, b) {
        var _a, _b, _c, _d, _e, _f;
        return {
            buildEnvironment: mergeBuildEnvironments(a.buildEnvironment, b.buildEnvironment),
            rolePolicy: definedArray([...(_a = a.rolePolicy) !== null && _a !== void 0 ? _a : [], ...(_b = b.rolePolicy) !== null && _b !== void 0 ? _b : []]),
            securityGroups: definedArray([...(_c = a.securityGroups) !== null && _c !== void 0 ? _c : [], ...(_d = b.securityGroups) !== null && _d !== void 0 ? _d : []]),
            partialBuildSpec: mergeBuildSpecs(a.partialBuildSpec, b.partialBuildSpec),
            vpc: (_e = b.vpc) !== null && _e !== void 0 ? _e : a.vpc,
            subnetSelection: (_f = b.subnetSelection) !== null && _f !== void 0 ? _f : a.subnetSelection,
        };
    }
}
exports.mergeCodeBuildOptions = mergeCodeBuildOptions;
function mergeBuildEnvironments(a, b) {
    var _a, _b, _c;
    if (!a || !b) {
        return a !== null && a !== void 0 ? a : b;
    }
    return {
        buildImage: (_a = b.buildImage) !== null && _a !== void 0 ? _a : a.buildImage,
        computeType: (_b = b.computeType) !== null && _b !== void 0 ? _b : a.computeType,
        environmentVariables: {
            ...a.environmentVariables,
            ...b.environmentVariables,
        },
        privileged: (_c = b.privileged) !== null && _c !== void 0 ? _c : a.privileged,
    };
}
function mergeBuildSpecs(a, b) {
    if (!a || !b) {
        return a !== null && a !== void 0 ? a : b;
    }
    return codebuild.mergeBuildSpecs(a, b);
}
exports.mergeBuildSpecs = mergeBuildSpecs;
function isDefined(x) {
    return x !== undefined;
}
function hash(obj) {
    const d = crypto.createHash('sha256');
    d.update(JSON.stringify(obj));
    return d.digest('hex');
}
/**
 * Serialize a build environment to data (get rid of constructs & objects), so we can JSON.stringify it
 */
function serializeBuildEnvironment(env) {
    var _a, _b, _c, _d, _e;
    return {
        privileged: env.privileged,
        environmentVariables: env.environmentVariables,
        type: (_a = env.buildImage) === null || _a === void 0 ? void 0 : _a.type,
        imageId: (_b = env.buildImage) === null || _b === void 0 ? void 0 : _b.imageId,
        computeType: env.computeType,
        imagePullPrincipalType: (_c = env.buildImage) === null || _c === void 0 ? void 0 : _c.imagePullPrincipalType,
        secretsManagerArn: (_e = (_d = env.buildImage) === null || _d === void 0 ? void 0 : _d.secretsManagerCredentials) === null || _e === void 0 ? void 0 : _e.secretArn,
    };
}
function stackVariableNamespace(stack) {
    return stack.stackArtifactId;
}
exports.stackVariableNamespace = stackVariableNamespace;
/**
 * Whether the given string contains a reference to a CodePipeline variable
 */
function containsPipelineVariable(s) {
    return !!s.match(/#\{[^}]+\}/);
}
/**
 * Turn a collection into a collection of CodePipeline environment variables
 */
function cbEnv(xs) {
    return javascript_1.mkdict(Object.entries(xs)
        .filter(([, v]) => v !== undefined)
        .map(([k, v]) => [k, { value: v }]));
}
function definedArray(xs) {
    return xs.length > 0 ? xs : undefined;
}
/**
 * If lines in the buildspec start with '!WINDOWS!' or '!LINUX!', only render them on that platform.
 *
 * Very private protocol for now, but may come in handy in other libraries as well.
 */
function filterBuildSpecCommands(buildSpec, osType) {
    if (!buildSpec.isImmediate) {
        return buildSpec;
    }
    const spec = buildSpec.spec;
    const winTag = '!WINDOWS!';
    const linuxTag = '!LINUX!';
    const expectedTag = osType === ec2.OperatingSystemType.WINDOWS ? winTag : linuxTag;
    return codebuild.BuildSpec.fromObject(recurse(spec));
    function recurse(x) {
        if (Array.isArray(x)) {
            const ret = [];
            for (const el of x) {
                const [tag, payload] = extractTag(el);
                if (tag === undefined || tag === expectedTag) {
                    ret.push(payload);
                }
            }
            return ret;
        }
        if (x && typeof x === 'object') {
            return javascript_1.mapValues(x, recurse);
        }
        return x;
    }
    function extractTag(x) {
        if (typeof x !== 'string') {
            return [undefined, x];
        }
        for (const tag of [winTag, linuxTag]) {
            if (x.startsWith(tag)) {
                return [tag, x.substr(tag.length)];
            }
        }
        return [undefined, x];
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiX2NvZGVidWlsZC1mYWN0b3J5LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiX2NvZGVidWlsZC1mYWN0b3J5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLGlDQUFpQztBQUNqQyx5QkFBeUI7QUFDekIsNkJBQTZCO0FBQzdCLG9EQUFvRDtBQUVwRCwwRUFBMEU7QUFDMUUsd0NBQXdDO0FBRXhDLHdDQUFtRDtBQUNuRCwyQ0FBNkM7QUFFN0MsMkVBQXVFO0FBQ3ZFLHdFQUF3RjtBQUN4RixzREFBaUc7QUFxR2pHOzs7OztHQUtHO0FBQ0gsTUFBYSxnQkFBZ0I7SUE2QzNCLFlBQ21CLFdBQW1CLEVBQ25CLEtBQTRCOztRQUQ1QixnQkFBVyxHQUFYLFdBQVcsQ0FBUTtRQUNuQixVQUFLLEdBQUwsS0FBSyxDQUF1QjtRQUU3QyxJQUFJLENBQUMsTUFBTSxTQUFHLEtBQUssQ0FBQyxNQUFNLG1DQUFJLFdBQVcsQ0FBQztJQUM1QyxDQUFDO0lBakRELG1DQUFtQztJQUM1QixNQUFNLENBQUMsYUFBYSxDQUFDLFdBQW1CLEVBQUUsU0FBb0IsRUFBRSxVQUEyQztRQUNoSCxPQUFPLElBQUksZ0JBQWdCLENBQUMsV0FBVyxFQUFFO1lBQ3ZDLFFBQVEsRUFBRSxTQUFTLENBQUMsUUFBUTtZQUM1QixHQUFHLEVBQUUsU0FBUyxDQUFDLEdBQUc7WUFDbEIsaUJBQWlCLEVBQUUsU0FBUyxDQUFDLGlCQUFpQjtZQUM5QyxNQUFNLEVBQUUsU0FBUyxDQUFDLE1BQU07WUFDeEIsT0FBTyxFQUFFLFNBQVMsQ0FBQyxPQUFPO1lBQzFCLE1BQU0sRUFBRSxTQUFTLENBQUMsRUFBRTtZQUNwQixlQUFlLEVBQUUsU0FBUyxDQUFDLGVBQWU7WUFDMUMsR0FBRyxVQUFVO1NBQ2QsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVNLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQyxXQUFtQixFQUFFLElBQW1CLEVBQUUsVUFBMkM7UUFDbkgsTUFBTSxPQUFPLEdBQUcsZ0JBQWdC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QUNELE9BQU8sQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDLENBQUM7SUFDeEIsQ0FBQztBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBjcnlwdG8gZnJvbSAnY3J5cHRvJztcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBjb2RlYnVpbGQgZnJvbSAnQGF3cy1jZGsvYXdzLWNvZGVidWlsZCc7XG5pbXBvcnQgKiBhcyBjb2RlcGlwZWxpbmUgZnJvbSAnQGF3cy1jZGsvYXdzLWNvZGVwaXBlbGluZSc7XG5pbXBvcnQgKiBhcyBjb2RlcGlwZWxpbmVfYWN0aW9ucyBmcm9tICdAYXdzLWNkay9hd3MtY29kZXBpcGVsaW5lLWFjdGlvbnMnO1xuaW1wb3J0ICogYXMgZWMyIGZyb20gJ0Bhd3MtY2RrL2F3cy1lYzInO1xuaW1wb3J0ICogYXMgaWFtIGZyb20gJ0Bhd3MtY2RrL2F3cy1pYW0nO1xuaW1wb3J0IHsgSURlcGVuZGFibGUsIFN0YWNrIH0gZnJvbSAnQGF3cy1jZGsvY29yZSc7XG5pbXBvcnQgeyBDb25zdHJ1Y3QsIE5vZGUgfSBmcm9tICdjb25zdHJ1Y3RzJztcbmltcG9ydCB7IEZpbGVTZXRMb2NhdGlvbiwgU2hlbGxTdGVwLCBTdGFja0RlcGxveW1lbnQsIFN0YWNrT3V0cHV0UmVmZXJlbmNlIH0gZnJvbSAnLi4vYmx1ZXByaW50JztcbmltcG9ydCB7IFBpcGVsaW5lUXVlcmllcyB9IGZyb20gJy4uL2hlbHBlcnMtaW50ZXJuYWwvcGlwZWxpbmUtcXVlcmllcyc7XG5pbXBvcnQgeyBjbG91ZEFzc2VtYmx5QnVpbGRTcGVjRGlyLCBvYnRhaW5TY29wZSB9IGZyb20gJy4uL3ByaXZhdGUvY29uc3RydWN0LWludGVybmFscyc7XG5pbXBvcnQgeyBtYXBWYWx1ZXMsIG1rZGljdCwgbm9FbXB0eU9iamVjdCwgbm9VbmRlZmluZWQsIHBhcnRpdGlvbiB9IGZyb20gJy4uL3ByaXZhdGUvamF2YXNjcmlwdCc7XG5pbXBvcnQgeyBBcnRpZmFjdE1hcCB9IGZyb20gJy4vYXJ0aWZhY3QtbWFwJztcbmltcG9ydCB7IENvZGVCdWlsZFN0ZXAgfSBmcm9tICcuL2NvZGVidWlsZC1zdGVwJztcbmltcG9ydCB7IENvZGVCdWlsZE9wdGlvbnMgfSBmcm9tICcuL2NvZGVwaXBlbGluZSc7XG5pbXBvcnQgeyBJQ29kZVBpcGVsaW5lQWN0aW9uRmFjdG9yeSwgUHJvZHVjZUFjdGlvbk9wdGlvbnMsIENvZGVQaXBlbGluZUFjdGlvbkZhY3RvcnlSZXN1bHQgfSBmcm9tICcuL2NvZGVwaXBlbGluZS1hY3Rpb24tZmFjdG9yeSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29kZUJ1aWxkRmFjdG9yeVByb3BzIHtcbiAgLyoqXG4gICAqIE5hbWUgZm9yIHRoZSBnZW5lcmF0ZWQgQ29kZUJ1aWxkIHByb2plY3RcbiAgICpcbiAgICogQGRlZmF1bHQgLSBBdXRvbWF0aWNhbGx5IGdlbmVyYXRlZFxuICAgKi9cbiAgcmVhZG9ubHkgcHJvamVjdE5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEN1c3RvbWl6YXRpb24gb3B0aW9ucyBmb3IgdGhlIHByb2plY3RcbiAgICpcbiAgICogV2lsbCBhdCBDb2RlQnVpbGQgcHJvZHVjdGlvbiB0aW1lIGJlIGNvbWJpbmVkIHdpdGggdGhlIG9wdGlvblxuICAgKiBkZWZhdWx0cyBjb25maWd1cmVkIG9uIHRoZSBwaXBlbGluZS5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyBzcGVjaWFsIHZhbHVlc1xuICAgKi9cbiAgcmVhZG9ubHkgcHJvamVjdE9wdGlvbnM/OiBDb2RlQnVpbGRPcHRpb25zO1xuXG4gIC8qKlxuICAgKiBDdXN0b20gZXhlY3V0aW9uIHJvbGUgdG8gYmUgdXNlZCBmb3IgdGhlIENvZGVCdWlsZCBwcm9qZWN0XG4gICAqXG4gICAqIEBkZWZhdWx0IC0gQSByb2xlIGlzIGF1dG9tYXRpY2FsbHkgY3JlYXRlZFxuICAgKi9cbiAgcmVhZG9ubHkgcm9sZT86IGlhbS5JUm9sZTtcblxuICAvKipcbiAgICogSWYgdHJ1ZSwgdGhlIGJ1aWxkIHNwZWMgd2lsbCBiZSBwYXNzZWQgdmlhIHRoZSBDbG91ZCBBc3NlbWJseSBpbnN0ZWFkIG9mIHJlbmRlcmVkIG9udG8gdGhlIFByb2plY3RcbiAgICpcbiAgICogRG9pbmcgdGhpcyBoYXMgdHdvIGFkdmFudGFnZXM6XG4gICAqXG4gICAqIC0gQnlwYXNzIHNpemUgcmVzdHJpY3Rpb25zOiB0aGUgYnVpbGRzcGVjIG9uIHRoZSBwcm9qZWN0IGlzIHJlc3RyaWN0ZWRcbiAgICogICBpbiBzaXplLCB3aGlsZSBidWlsZHNwZWNzIGNvbWluZyBmcm9tIGFuIGlucHV0IGFydGlmYWN0IGFyZSBub3QgcmVzdHJpY3RlZFxuICAgKiAgIGluIHN1Y2ggYSB3YXkuXG4gICAqIC0gQnlwYXNzIHBpcGVsaW5lIHVwZGF0ZTogaWYgdGhlIFNlbGZVcGRhdGUgc3RlcCBoYXMgdG8gY2hhbmdlIHRoZSBidWlsZHNwZWMsXG4gICAqICAgdGhhdCBqdXN0IHRha2VzIHRpbWUuIE9uIHRoZSBvdGhlciBoYW5kLCBpZiB0aGUgYnVpbGRzcGVjIGNvbWVzIGZyb20gdGhlXG4gICAqICAgcGlwZWxpbmUgYXJ0aWZhY3QsIG5vIHN1Y2ggdXBkYXRlIGhhcyB0byB0YWtlIHBsYWNlLlxuICAgKlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgcGFzc0J1aWxkU3BlY1ZpYUNsb3VkQXNzZW1ibHk/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgY29uc3RydWN0IHRyZWUgd2hlcmUgdGhlIENvZGVCdWlsZCBwcm9qZWN0IGlzIGNyZWF0ZWQuXG4gICAqXG4gICAqIE5vcm1hbGx5LCB0aGUgY29uc3RydWN0IHRyZWUgd2lsbCBsb29rIGxpa2UgdGhpczpcbiAgICpcbiAgICogIOKUgOKUgCBQaXBlbGluZVxuICAgKiAgICAgIOKUlOKUgOKUgCAnTXlTdGFnZScgICAgICAgICA8LSBvcHRpb25zLnNjb3BlXG4gICAqICAgICAgICAgICDilJTilIDilIAgJ015QWN0aW9uJyAgIDwtIHRoaXMgaXMgdGhlIENvZGVCdWlsZCBwcm9qZWN0XG4gICAqXG4gICAqIElmIHRoaXMgZmxhZyBpcyBzZXQsIHRoZSBjb25zdHJ1Y3QgdHJlZSB3aWxsIGxvb2sgbGlrZSB0aGlzOlxuICAgKlxuICAgKiAg4pSA4pSAIFBpcGVsaW5lXG4gICAqICAgICAg4pSU4pSA4pSAICdNeVN0YWdlJyAgICAgICAgICAgICAgICAgICAgICAgICA8LSBvcHRpb25zLnNjb3BlXG4gICAqICAgICAgICAgICDilJTilIDilIAgJ015QWN0aW9uJyAgICAgICAgICAgICAgICAgICA8LSBqdXN0IGEgc2NvcGVcbiAgICogICAgICAgICAgICAgICAgICDilJTilIDilIAgJ0JhY2t3YXJkc0NvbXBhdE5hbWUnIDwtIENvZGVCdWlsZCBwcm9qZWN0XG4gICAqXG4gICAqIFRoaXMgaXMgdG8gbWFpbnRhaW4gbG9naWNhbElEIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgcHJldmlvdXMgaXRlcmF0aW9uXG4gICAqIG9mIHBpcGVsaW5lcyAod2hlcmUgdGhlIEFjdGlvbiB3YXMgYSBjb25zdHJ1Y3QgdGhhdCB3b3VsZCBjcmVhdGUgdGhlIFByb2plY3QpLlxuICAgKlxuICAgKiBAZGVmYXVsdCB0cnVlXG4gICAqL1xuICByZWFkb25seSBhZGRpdGlvbmFsQ29uc3RydWN0TGV2ZWw/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBZGRpdGlvbmFsIGRlcGVuZGVuY3kgdGhhdCB0aGUgQ29kZUJ1aWxkIHByb2plY3Qgc2hvdWxkIHRha2VcbiAgICpcbiAgICogQGRlZmF1bHQgLVxuICAgKi9cbiAgcmVhZG9ubHkgYWRkaXRpb25hbERlcGVuZGFibGU/OiBJRGVwZW5kYWJsZTtcblxuICByZWFkb25seSBpbnB1dHM/OiBGaWxlU2V0TG9jYXRpb25bXTtcbiAgcmVhZG9ubHkgb3V0cHV0cz86IEZpbGVTZXRMb2NhdGlvbltdO1xuXG4gIHJlYWRvbmx5IHN0ZXBJZD86IHN0cmluZztcblxuICByZWFkb25seSBjb21tYW5kczogc3RyaW5nW107XG4gIHJlYWRvbmx5IGluc3RhbGxDb21tYW5kcz86IHN0cmluZ1tdO1xuXG4gIHJlYWRvbmx5IGVudj86IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIHJlYWRvbmx5IGVudkZyb21DZm5PdXRwdXRzPzogUmVjb3JkPHN0cmluZywgU3RhY2tPdXRwdXRSZWZlcmVuY2U+O1xuXG4gIC8qKlxuICAgKiBJZiBnaXZlbiwgb3ZlcnJpZGUgdGhlIHNjb3BlIGZyb20gdGhlIHByb2R1Y2UgY2FsbCB3aXRoIHRoaXMgc2NvcGUuXG4gICAqL1xuICByZWFkb25seSBzY29wZT86IENvbnN0cnVjdDtcblxuICAvKipcbiAgICogV2hldGhlciBvciBub3QgdGhlIGdpdmVuIENvZGVCdWlsZCBwcm9qZWN0IGlzIGdvaW5nIHRvIGJlIHRoZSBzeW50aCBzdGVwXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBpc1N5bnRoPzogYm9vbGVhbjtcbn1cblxuLyoqXG4gKiBQcm9kdWNlIGEgQ29kZUJ1aWxkIHByb2plY3QgZnJvbSBhIFNoZWxsU3RlcCBhbmQgc29tZSBDb2RlQnVpbGQtc3BlY2lmaWMgY3VzdG9taXphdGlvbnNcbiAqXG4gKiBUaGUgZnVuY3Rpb25hbGl0eSBoZXJlIGlzIHNoYXJlZCBiZXR3ZWVuIHRoZSBgQ29kZVBpcGVsaW5lYCB0cmFuc2xhdGluZyBhIGBTaGVsbFN0ZXBgIGludG9cbiAqIGEgQ29kZUJ1aWxkIHByb2plY3QsIGFzIHdlbGwgYXMgdGhlIGBDb2RlQnVpbGRTdGVwYCBzdHJhaWdodCB1cC5cbiAqL1xuZXhwb3J0IGNsYXNzIENvZGVCdWlsZEZhY3RvcnkgaW1wbGVtZW50cyBJQ29kZVBpcGVsaW5lQWN0aW9uRmFjdG9yeSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIHB1YmxpYyBzdGF0aWMgZnJvbVNoZWxsU3RlcChjb25zdHJ1Y3RJZDogc3RyaW5nLCBzaGVsbFN0ZXA6IFNoZWxsU3RlcCwgYWRkaXRpb25hbD86IFBhcnRpYWw8Q29kZUJ1aWxkRmFjdG9yeVByb3BzPik6IElDb2RlUGlwZWxpbmVBY3Rpb25GYWN0b3J5IHtcbiAgICByZXR1cm4gbmV3IENvZGVCdWlsZEZhY3RvcnkoY29uc3RydWN0SWQsIHtcbiAgICAgIGNvbW1hbmRzOiBzaGVsbFN0ZXAuY29tbWFuZHMsXG4gICAgICBlbnY6IHNoZWxsU3RlcC5lbnYsXG4gICAgICBlbnZGcm9tQ2ZuT3V0cHV0czogc2hlbGxTdGVwLmVudkZyb21DZm5PdXRwdXRzLFxuICAgICAgaW5wdXRzOiBzaGVsbFN0ZXAuaW5wdXRzLFxuICAgICAgb3V0cHV0czogc2hlbGxTdGVwLm91dHB1dHMsXG4gICAgICBzdGVwSWQ6IHNoZWxsU3RlcC5pZCxcbiAgICAgIGluc3RhbGxDb21tYW5kczogc2hlbGxTdGVwLmluc3RhbGxDb21tYW5kcyxcbiAgICAgIC4uLmFkZGl0aW9uYWwsXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgc3RhdGljIGZyb21Db2RlQnVpbGRTdGVwKGNvbnN0cnVjdElkOiBzdHJpbmcsIHN0ZXA6IENvZGVCdWlsZFN0ZXAsIGFkZGl0aW9uYWw/OiBQYXJ0aWFsPENvZGVCdWlsZEZhY3RvcnlQcm9wcz4pOiBJQ29kZVBpcGVsaW5lQWN0aW9uRmFjdG9yeSB7XG4gICAgY29uc3QgZmFjdG9yeSA9IENvZGVCdWlsZEZhY3RvcnkuZnJvbVNoZWxsU3RlcChjb25zdHJ1Y3RJZCwgc3RlcCwge1xuICAgICAgcHJvamVjdE5hbWU6IHN0ZXAucHJvamVjdE5hbWUsXG4gICAgICByb2xlOiBzdGVwLnJvbGUsXG4gICAgICBwcm9qZWN0T3B0aW9uczoge1xuICAgICAgICBidWlsZEVudmlyb25tZW50OiBzdGVwLmJ1aWxkRW52aXJvbm1lbnQsXG4gICAgICAgIHJvbGVQb2xpY3k6IHN0ZXAucm9sZVBvbGljeVN0YXRlbWVudHMsXG4gICAgICAgIHNlY3VyaXR5R3JvdXBzOiBzdGVwLnNlY3VyaXR5R3JvdXBzLFxuICAgICAgICBwYXJ0aWFsQnVpbGRTcGVjOiBzdGVwLnBhcnRpYWxCdWlsZFNwZWMsXG4gICAgICAgIHZwYzogc3RlcC52cGMsXG4gICAgICAgIHN1Ym5ldFNlbGVjdGlvbjogc3RlcC5zdWJuZXRTZWxlY3Rpb24sXG4gICAgICAgIC4uLmFkZGl0aW9uYWw/LnByb2plY3RPcHRpb25zLFxuICAgICAgfSxcbiAgICAgIC4uLmFkZGl0aW9uYWwsXG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgcHJvZHVjZUFjdGlvbjogKHN0YWdlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZhY3RvcnkucHJvZHVjZUFjdGlvbihzdGFnZSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChyZXN1bHQucHJvamVjdCkge1xuICAgICAgICAgIHN0ZXAuX3NldFByb2plY3QocmVzdWx0LnByb2plY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9LFxuICAgIH07XG4gIH1cblxuICBwcml2YXRlIF9wcm9qZWN0PzogY29kZWJ1aWxkLklQcm9qZWN0O1xuICBwcml2YXRlIHN0ZXBJZDogc3RyaW5nO1xuXG4gIHByaXZhdGUgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBjb25zdHJ1Y3RJZDogc3RyaW5nLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcHJvcHM6IENvZGVCdWlsZEZhY3RvcnlQcm9wcykge1xuXG4gICAgdGhpcy5zdGVwSWQgPSBwcm9wcy5zdGVwSWQgPz8gY29uc3RydWN0SWQ7XG4gIH1cblxuICBwdWJsaWMgZ2V0IHByb2plY3QoKTogY29kZWJ1aWxkLklQcm9qZWN0IHtcbiAgICBpZiAoIXRoaXMuX3Byb2plY3QpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUHJvamVjdCBiZWNvbWVzIGF2YWlsYWJsZSBhZnRlciBwcm9kdWNlKCkgaGFzIGJlZW4gY2FsbGVkJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wcm9qZWN0O1xuICB9XG5cbiAgcHVibGljIHByb2R1Y2VBY3Rpb24oc3RhZ2U6IGNvZGVwaXBlbGluZS5JU3RhZ2UsIG9wdGlvbnM6IFByb2R1Y2VBY3Rpb25PcHRpb25zKTogQ29kZVBpcGVsaW5lQWN0aW9uRmFjdG9yeVJlc3VsdCB7XG4gICAgY29uc3QgcHJvamVjdE9wdGlvbnMgPSBtZXJnZUNvZGVCdWlsZE9wdGlvbnMob3B0aW9ucy5jb2RlQnVpbGREZWZhdWx0cywgdGhpcy5wcm9wcy5wcm9qZWN0T3B0aW9ucyk7XG5cbiAgICBjb25zdCBpbnB1dHMgPSB0aGlzLnByb3BzLmlucHV0cyA/PyBbXTtcbiAgICBjb25zdCBvdXRwdXRzID0gdGhpcy5wcm9wcy5vdXRwdXRzID8/IFtdO1xuXG4gICAgY29uc3QgbWFpbklucHV0ID0gaW5wdXRzLmZpbmQoeCA9PiB4LmRpcmVjdG9yeSA9PT0gJy4nKTtcbiAgICBjb25zdCBleHRyYUlucHV0cyA9IGlucHV0cy5maWx0ZXIoeCA9PiB4LmRpcmVjdG9yeSAhPT0gJy4nKTtcblxuICAgIGNvbnN0IGlucHV0QXJ0aWZhY3QgPSBtYWluSW5wdXRcbiAgICAgID8gb3B0aW9ucy5hcnRpZmFjdHMudG9Db2RlUGlwZWxpbmUobWFpbklucHV0LmZpbGVTZXQpXG4gICAgICA6IG9wdGlvbnMuZmFsbGJhY2tBcnRpZmFjdDtcbiAgICBjb25zdCBleHRyYUlucHV0QXJ0aWZhY3RzID0gZXh0cmFJbnB1dHMubWFwKHggPT4gb3B0aW9ucy5hcnRpZmFjdHMudG9Db2RlUGlwZWxpbmUoeC5maWxlU2V0KSk7XG4gICAgY29uc3Qgb3V0cHV0QXJ0aWZhY3RzID0gb3V0cHV0cy5tYXAoeCA9PiBvcHRpb25zLmFydGlmYWN0cy50b0NvZGVQaXBlbGluZSh4LmZpbGVTZXQpKTtcblxuICAgIGlmICghaW5wdXRBcnRpZmFjdCkge1xuICAgICAgLy8gVGhpcyBzaG91bGQgYWN0dWFsbHkgbmV2ZXIgaGFwcGVuIGJlY2F1c2UgQ29kZUJ1aWxkIHByb2plY3RzIHNob3VsZG4ndCBiZSBhZGRlZCBiZWZvcmUgdGhlXG4gICAgICAvLyBTb3VyY2UsIHdoaWNoIGFsd2F5cyBwcm9kdWNlcyBhdCBsZWFzdCBhbiBhcnRpZmFjdC5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ29kZUJ1aWxkIGFjdGlvbiAnJHt0aGlzLnN0ZXBJZH0nIHJlcXVpcmVzIGFuIGlucHV0IChhbmQgdGhlIHBpcGVsaW5lIGRvZXNuJ3QgaGF2ZSBhIFNvdXJjZSB0byBmYWxsIGJhY2sgdG8pLiBBZGQgYW4gaW5wdXQgb3IgYSBwaXBlbGluZSBzb3VyY2UuYCk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5zdGFsbENvbW1hbmRzID0gW1xuICAgICAgLi4uZ2VuZXJhdGVJbnB1dEFydGlmYWN0TGlua0NvbW1hbmRzKG9wdGlvbnMuYXJ0aWZhY3RzLCBleHRyYUlucHV0cyksXG4gICAgICAuLi50aGlzLnByb3BzLmluc3RhbGxDb21tYW5kcyA/PyBbXSxcbiAgICBdO1xuXG4gICAgY29uc3QgYnVpbGRTcGVjSGVyZSA9IGNvZGVidWlsZC5CdWlsZFNwZWMuZnJvbU9iamVjdCh7XG4gICAgICB2ZXJzaW9uOiAnMC4yJyxcbiAgICAgIHBoYXNlczoge1xuICAgICAgICBpbnN0YWxsOiAoaW5zdGFsbENvbW1hbmRzLmxlbmd0aCA/PyAwKSA+IDAgPyB7IGNvbW1hbmRzOiBpbnN0YWxsQ29tbWFuZHMgfSA6IHVuZGVmaW5lZCxcbiAgICAgICAgYnVpbGQ6IHRoaXMucHJvcHMuY29tbWFuZHMubGVuZ3RoID4gMCA/IHsgY29tbWFuZHM6IHRoaXMucHJvcHMuY29tbWFuZHMgfSA6IHVuZGVmaW5lZCxcbiAgICAgIH0sXG4gICAgICBhcnRpZmFjdHM6IG5vRW1wdHlPYmplY3Q8YW55PihyZW5kZXJBcnRpZmFjdHNCdWlsZFNwZWMob3B0aW9ucy5hcnRpZmFjdHMsIHRoaXMucHJvcHMub3V0cHV0cyA/PyBbXSkpLFxuICAgIH0pO1xuXG4gICAgLy8gUGFydGl0aW9uIGVudmlyb25tZW50IHZhcmlhYmxlcyBpbnRvIGVudmlyb25tZW50IHZhcmlhYmxlcyB0aGF0IGNhbiBnbyBvbiB0aGUgcHJvamVjdFxuICAgIC8vIGFuZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMgdGhhdCBNVVNUIGdvIGluIHRoZSBwaXBlbGluZSAodGhvc2UgdGhhdCByZWZlcmVuY2UgQ29kZVBpcGVsaW5lIHZhcmlhYmxlcylcbiAgICBjb25zdCBlbnYgPSBub1VuZGVmaW5lZCh0aGlzLnByb3BzLmVudiA/PyB7fSk7XG5cbiAgICBjb25zdCBbYWN0aW9uRW52cywgcHJvamVjdEVudnNdID0gcGFydGl0aW9uKE9iamVjdC5lbnRyaWVzKGVudiA/PyB7fSksIChbLCB2XSkgPT4gY29udGFpbnNQaXBlbGluZVZhcmlhYmxlKHYpKTtcblxuICAgIGNvbnN0IGVudmlyb25tZW50ID0gbWVyZ2VCdWlsZEVudmlyb25tZW50cyhcbiAgICAgIHByb2plY3RPcHRpb25zPy5idWlsZEVudmlyb25tZW50ID8/IHt9LFxuICAgICAge1xuICAgICAgICBlbnZpcm9ubWVudFZhcmlhYmxlczogbm9FbXB0eU9iamVjdChtYXBWYWx1ZXMobWtkaWN0KHByb2plY3RFbnZzKSwgdmFsdWUgPT4gKHsgdmFsdWUgfSkpKSxcbiAgICAgIH0pO1xuXG4gICAgY29uc3QgZnVsbEJ1aWxkU3BlYyA9IHByb2plY3RPcHRpb25zPy5wYXJ0aWFsQnVpbGRTcGVjXG4gICAgICA/IGNvZGVidWlsZC5tZXJnZUJ1aWxkU3BlY3MocHJvamVjdE9wdGlvbnMucGFydGlhbEJ1aWxkU3BlYywgYnVpbGRTcGVjSGVyZSlcbiAgICAgIDogYnVpbGRTcGVjSGVyZTtcblxuICAgIGNvbnN0IG9zRnJvbUVudmlyb25tZW50ID0gZW52aXJvbm1lbnQuYnVpbGRJbWFnZSAmJiBlbnZpcm9ubWVudC5idWlsZEltYWdlIGluc3RhbmNlb2YgY29kZWJ1aWxkLldpbmRvd3NCdWlsZEltYWdlXG4gICAgICA/IGVjMi5PcGVyYXRpbmdTeXN0ZW1UeXBlLldJTkRPV1NcbiAgICAgIDogZWMyLk9wZXJhdGluZ1N5c3RlbVR5cGUuTElOVVg7XG5cbiAgICBjb25zdCBhY3R1YWxCdWlsZFNwZWMgPSBmaWx0ZXJCdWlsZFNwZWNDb21tYW5kcyhmdWxsQnVpbGRTcGVjLCBvc0Zyb21FbnZpcm9ubWVudCk7XG5cbiAgICBjb25zdCBzY29wZSA9IHRoaXMucHJvcHMuc2NvcGUgPz8gb3B0aW9ucy5zY29wZTtcblxuICAgIGxldCBwcm9qZWN0QnVpbGRTcGVjO1xuICAgIGlmICh0aGlzLnByb3BzLnBhc3NCdWlsZFNwZWNWaWFDbG91ZEFzc2VtYmx5KSB7XG4gICAgICAvLyBXcml0ZSB0byBkaXNrIGFuZCByZXBsYWNlIHdpdGggYSByZWZlcmVuY2VcbiAgICAgIGNvbnN0IHJlbGF0aXZlU3BlY0ZpbGUgPSBgYnVpbGRzcGVjLSR7Tm9kZS5vZihzY29wZSkuYWRkcn0tJHt0aGlzLmNvbnN0cnVjdElkfS55YW1sYDtcbiAgICAgIGNvbnN0IGFic1NwZWNGaWxlID0gcGF0aC5qb2luKGNsb3VkQXNzZW1ibHlCdWlsZFNwZWNEaXIoc2NvcGUpLCByZWxhdGl2ZVNwZWNGaWxlKTtcbiAgICAgIGZzLndyaXRlRmlsZVN5bmMoYWJzU3BlY0ZpbGUsIFN0YWNrLm9mKHNjb3BlKS5yZXNvbHZlKGFjdHVhbEJ1aWxkU3BlYy50b0J1aWxkU3BlYygpKSwgeyBlbmNvZGluZzogJ3V0Zi04JyB9KTtcbiAgICAgIHByb2plY3RCdWlsZFNwZWMgPSBjb2RlYnVpbGQuQnVpbGRTcGVjLmZyb21Tb3VyY2VGaWxlbmFtZShyZWxhdGl2ZVNwZWNGaWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvamVjdEJ1aWxkU3BlYyA9IGFjdHVhbEJ1aWxkU3BlYztcbiAgICB9XG5cbiAgICAvLyBBIGhhc2ggb3ZlciB0aGUgdmFsdWVzIHRoYXQgbWFrZSB0aGUgQ29kZUJ1aWxkIFByb2plY3QgdW5pcXVlIChhbmQgbmVjZXNzYXJ5XG4gICAgLy8gdG8gcmVzdGFydCB0aGUgcGlwZWxpbmUgaWYgb25lIG9mIHRoZW0gY2hhbmdlcykuIHByb2plY3ROYW1lIGlzIG5vdCBuZWNlc3NhcnkgdG8gaW5jbHVkZVxuICAgIC8vIGhlcmUgYmVjYXVzZSB0aGUgcGlwZWxpbmUgd2lsbCBkZWZpbml0ZWx5IHJlc3RhcnQgaWYgcHJvamVjdE5hbWUgY2hhbmdlcy5cbiAgICAvLyAoUmVzb2x2ZSB0b2tlbnMpXG4gICAgY29uc3QgcHJvamVjdENvbmZpZ0hhc2ggPSBoYXNoKFN0YWNrLm9mKHNjb3BlKS5yZXNvbHZlKHtcbiAgICAgIGVudmlyb25tZW50OiBzZXJpYWxpemVCdWlsZEVudmlyb25tZW50KGVudmlyb25tZW50KSxcbiAgICAgIGJ1aWxkU3BlY1N0cmluZzogYWN0dWFsQnVpbGRTcGVjLnRvQnVpbGRTcGVjKCksXG4gICAgfSkpO1xuXG4gICAgY29uc3QgYWN0aW9uTmFtZSA9IG9wdGlvbnMuYWN0aW9uTmFtZSA/PyB0aGlzLnN0ZXBJZDtcblxuICAgIGxldCBwcm9qZWN0U2NvcGUgPSBzY29wZTtcbiAgICBpZiAodGhpcy5wcm9wcy5hZGRpdGlvbmFsQ29uc3RydWN0TGV2ZWwgPz8gdHJ1ZSkge1xuICAgICAgcHJvamVjdFNjb3BlID0gb2J0YWluU2NvcGUoc2NvcGUsIGFjdGlvbk5hbWUpO1xuICAgIH1cblxuICAgIGNvbnN0IHByb2plY3QgPSBuZXcgY29kZWJ1aWxkLlBpcGVsaW5lUHJvamVjdChwcm9qZWN0U2NvcGUsIHRoaXMuY29uc3RydWN0SWQsIHtcbiAgICAgIHByb2plY3ROYW1lOiB0aGlzLnByb3BzLnByb2plY3ROYW1lLFxuICAgICAgZW52aXJvbm1lbnQsXG4gICAgICB2cGM6IHByb2plY3RPcHRpb25zLnZwYyxcbiAgICAgIHN1Ym5ldFNlbGVjdGlvbjogcHJvamVjdE9wdGlvbnMuc3VibmV0U2VsZWN0aW9uLFxuICAgICAgc2VjdXJpdHlHcm91cHM6IHByb2plY3RPcHRpb25zLnNlY3VyaXR5R3JvdXBzLFxuICAgICAgYnVpbGRTcGVjOiBwcm9qZWN0QnVpbGRTcGVjLFxuICAgICAgcm9sZTogdGhpcy5wcm9wcy5yb2xlLFxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMucHJvcHMuYWRkaXRpb25hbERlcGVuZGFibGUpIHtcbiAgICAgIHByb2plY3Qubm9kZS5hZGREZXBlbmRlbmN5KHRoaXMucHJvcHMuYWRkaXRpb25hbERlcGVuZGFibGUpO1xuICAgIH1cblxuICAgIGlmIChwcm9qZWN0T3B0aW9ucy5yb2xlUG9saWN5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHByb2plY3RPcHRpb25zLnJvbGVQb2xpY3kuZm9yRWFjaChwb2xpY3lTdGF0ZW1lbnQgPT4ge1xuICAgICAgICBwcm9qZWN0LmFkZFRvUm9sZVBvbGljeShwb2xpY3lTdGF0ZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcXVlcmllcyA9IG5ldyBQaXBlbGluZVF1ZXJpZXMob3B0aW9ucy5waXBlbGluZSk7XG5cbiAgICBjb25zdCBzdGFja091dHB1dEVudiA9IG1hcFZhbHVlcyh0aGlzLnByb3BzLmVudkZyb21DZm5PdXRwdXRzID8/IHt9LCBvdXRwdXRSZWYgPT5cbiAgICAgIGAjeyR7c3RhY2tWYXJpYWJsZU5hbWVzcGFjZShxdWVyaWVzLnByb2R1Y2luZ1N0YWNrKG91dHB1dFJlZikpfS4ke291dHB1dFJlZi5vdXRwdXROYW1lfX1gLFxuICAgICk7XG5cbiAgICBjb25zdCBjb25maWdIYXNoRW52ID0gb3B0aW9ucy5iZWZvcmVTZWxmTXV0YXRpb25cbiAgICAgID8geyBfUFJPSkVDVF9DT05GSUdfSEFTSDogcHJvamVjdENvbmZpZ0hhc2ggfVxuICAgICAgOiB7fTtcblxuICAgIHN0YWdlLmFkZEFjdGlvbihuZXcgY29kZXBpcGVsaW5lX2FjdGlvbnMuQ29kZUJ1aWxkQWN0aW9uKHtcbiAgICAgIGFjdGlvbk5hbWU6IGFjdGlvbk5hbWUsXG4gICAgICBpbnB1dDogaW5wdXRBcnRpZmFjdCxcbiAgICAgIGV4dHJhSW5wdXRzOiBleHRyYUlucHV0QXJ0aWZhY3RzLFxuICAgICAgb3V0cHV0czogb3V0cHV0QXJ0aWZhY3RzLFxuICAgICAgcHJvamVjdCxcbiAgICAgIHJ1bk9yZGVyOiBvcHRpb25zLnJ1bk9yZGVyLFxuXG4gICAgICAvLyBJbmNsdXNpb24gb2YgdGhlIGhhc2ggaGVyZSB3aWxsIGxlYWQgdG8gdGhlIHBpcGVsaW5lIHN0cnVjdHVyZSBmb3IgYW55IGNoYW5nZXNcbiAgICAgIC8vIG1hZGUgdGhlIGNvbmZpZyBvZiB0aGUgdW5kZXJseWluZyBDb2RlQnVpbGQgUHJvamVjdC5cbiAgICAgIC8vIEhlbmNlLCB0aGUgcGlwZWxpbmUgd2lsbCBiZSByZXN0YXJ0ZWQuIFRoaXMgaXMgbmVjZXNzYXJ5IGlmIHRoZSB1c2Vyc1xuICAgICAgLy8gYWRkcyAoZm9yIGV4YW1wbGUpIGJ1aWxkIG9yIHRlc3QgY29tbWFuZHMgdG8gdGhlIGJ1aWxkc3BlYy5cbiAgICAgIGVudmlyb25tZW50VmFyaWFibGVzOiBub0VtcHR5T2JqZWN0KGNiRW52KHtcbiAgICAgICAgLi4ubWtkaWN0KGFjdGlvbkVudnMpLFxuICAgICAgICAuLi5jb25maWdIYXNoRW52LFxuICAgICAgICAuLi5zdGFja091dHB1dEVudixcbiAgICAgIH0pKSxcbiAgICB9KSk7XG5cbiAgICB0aGlzLl9wcm9qZWN0ID0gcHJvamVjdDtcblxuICAgIHJldHVybiB7IHJ1bk9yZGVyc0NvbnN1bWVkOiAxLCBwcm9qZWN0IH07XG4gIH1cbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBjb21tYW5kcyB0byBtb3ZlIGFkZGl0aW9uYWwgaW5wdXQgYXJ0aWZhY3RzIGludG8gdGhlIHJpZ2h0IHBsYWNlXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlSW5wdXRBcnRpZmFjdExpbmtDb21tYW5kcyhhcnRpZmFjdHM6IEFydGlmYWN0TWFwLCBpbnB1dHM6IEZpbGVTZXRMb2NhdGlvbltdKTogc3RyaW5nW10ge1xuICByZXR1cm4gaW5wdXRzLm1hcChpbnB1dCA9PiB7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gW107XG5cbiAgICBpZiAoIVsnLicsICcuLiddLmluY2x1ZGVzKHBhdGguZGlybmFtZShpbnB1dC5kaXJlY3RvcnkpKSkge1xuICAgICAgZnJhZ21lbnRzLnB1c2goYG1rZGlyIC1wIFwiJHtpbnB1dC5kaXJlY3Rvcnl9XCJgKTtcbiAgICB9XG5cbiAgICBjb25zdCBhcnRpZmFjdCA9IGFydGlmYWN0cy50b0NvZGVQaXBlbGluZShpbnB1dC5maWxlU2V0KTtcblxuICAgIGZyYWdtZW50cy5wdXNoKGBsbiAtcyBcIiRDT0RFQlVJTERfU1JDX0RJUl8ke2FydGlmYWN0LmFydGlmYWN0TmFtZX1cIiBcIiR7aW5wdXQuZGlyZWN0b3J5fVwiYCk7XG5cbiAgICByZXR1cm4gZnJhZ21lbnRzLmpvaW4oJyAmJiAnKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJlbmRlckFydGlmYWN0c0J1aWxkU3BlYyhhcnRpZmFjdE1hcDogQXJ0aWZhY3RNYXAsIG91dHB1dHM6IEZpbGVTZXRMb2NhdGlvbltdKSB7XG4gIC8vIHNhdmUgdGhlIGdlbmVyYXRlZCBmaWxlcyBpbiB0aGUgb3V0cHV0IGFydGlmYWN0XG4gIC8vIFRoaXMgcGFydCBvZiB0aGUgYnVpbGRzcGVjIGhhcyB0byBsb29rIGNvbXBsZXRlbHkgZGlmZmVyZW50IGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlJ3JlXG4gIC8vIHVzaW5nIHNlY29uZGFyeSBhcnRpZmFjdHMgb3Igbm90LlxuICBpZiAob3V0cHV0cy5sZW5ndGggPT09IDApIHsgcmV0dXJuIHt9OyB9XG5cbiAgaWYgKG91dHB1dHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICdiYXNlLWRpcmVjdG9yeSc6IG91dHB1dHNbMF0uZGlyZWN0b3J5LFxuICAgICAgJ2ZpbGVzJzogJyoqLyonLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBzZWNvbmRhcnk6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcbiAgZm9yIChjb25zdCBvdXRwdXQgb2Ygb3V0cHV0cykge1xuICAgIGNvbnN0IGFydCA9IGFydGlmYWN0TWFwLnRvQ29kZVBpcGVsaW5lKG91dHB1dC5maWxlU2V0KTtcblxuICAgIGlmICghYXJ0LmFydGlmYWN0TmFtZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdZb3UgbXVzdCBnaXZlIHRoZSBvdXRwdXQgYXJ0aWZhY3QgYSBuYW1lJyk7XG4gICAgfVxuICAgIHNlY29uZGFyeVthcnQuYXJ0aWZhY3ROYW1lXSA9IHtcbiAgICAgICdiYXNlLWRpcmVjdG9yeSc6IG91dHB1dC5kaXJlY3RvcnksXG4gICAgICAnZmlsZXMnOiAnKiovKicsXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiB7ICdzZWNvbmRhcnktYXJ0aWZhY3RzJzogc2Vjb25kYXJ5IH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUNvZGVCdWlsZE9wdGlvbnMoLi4ub3B0czogQXJyYXk8Q29kZUJ1aWxkT3B0aW9ucyB8IHVuZGVmaW5lZD4pIHtcbiAgY29uc3QgeHMgPSBbe30sIC4uLm9wdHMuZmlsdGVyKGlzRGVmaW5lZCldO1xuICB3aGlsZSAoeHMubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IFthLCBiXSA9IHhzLnNwbGljZSh4cy5sZW5ndGggLSAyLCAyKTtcbiAgICB4cy5wdXNoKG1lcmdlMihhLCBiKSk7XG4gIH1cbiAgcmV0dXJuIHhzWzBdO1xuXG4gIGZ1bmN0aW9uIG1lcmdlMihhOiBDb2RlQnVpbGRPcHRpb25zLCBiOiBDb2RlQnVpbGRPcHRpb25zKTogQ29kZUJ1aWxkT3B0aW9ucyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJ1aWxkRW52aXJvbm1lbnQ6IG1lcmdlQnVpbGRFbnZpcm9ubWVudHMoYS5idWlsZEVudmlyb25tZW50LCBiLmJ1aWxkRW52aXJvbm1lbnQpLFxuICAgICAgcm9sZVBvbGljeTogZGVmaW5lZEFycmF5KFsuLi5hLnJvbGVQb2xpY3kgPz8gW10sIC4uLmIucm9sZVBvbGljeSA/PyBbXV0pLFxuICAgICAgc2VjdXJpdHlHcm91cHM6IGRlZmluZWRBcnJheShbLi4uYS5zZWN1cml0eUdyb3VwcyA/PyBbXSwgLi4uYi5zZWN1cml0eUdyb3VwcyA/PyBbXV0pLFxuICAgICAgcGFydGlhbEJ1aWxkU3BlYzogbWVyZ2VCdWlsZFNwZWNzKGEucGFydGlhbEJ1aWxkU3BlYywgYi5wYXJ0aWFsQnVpbGRTcGVjKSxcbiAgICAgIHZwYzogYi52cGMgPz8gYS52cGMsXG4gICAgICBzdWJuZXRTZWxlY3Rpb246IGIuc3VibmV0U2VsZWN0aW9uID8/IGEuc3VibmV0U2VsZWN0aW9uLFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VCdWlsZEVudmlyb25tZW50cyhhOiBjb2RlYnVpbGQuQnVpbGRFbnZpcm9ubWVudCwgYj86IGNvZGVidWlsZC5CdWlsZEVudmlyb25tZW50KTogY29kZWJ1aWxkLkJ1aWxkRW52aXJvbm1lbnQ7XG5mdW5jdGlvbiBtZXJnZUJ1aWxkRW52aXJvbm1lbnRzKGE6IGNvZGVidWlsZC5CdWlsZEVudmlyb25tZW50IHwgdW5kZWZpbmVkLCBiOiBjb2RlYnVpbGQuQnVpbGRFbnZpcm9ubWVudCk6IGNvZGVidWlsZC5CdWlsZEVudmlyb25tZW50O1xuZnVuY3Rpb24gbWVyZ2VCdWlsZEVudmlyb25tZW50cyhhPzogY29kZWJ1aWxkLkJ1aWxkRW52aXJvbm1lbnQsIGI/OiBjb2RlYnVpbGQuQnVpbGRFbnZpcm9ubWVudCk6IGNvZGVidWlsZC5CdWlsZEVudmlyb25tZW50IHwgdW5kZWZpbmVkO1xuZnVuY3Rpb24gbWVyZ2VCdWlsZEVudmlyb25tZW50cyhhPzogY29kZWJ1aWxkLkJ1aWxkRW52aXJvbm1lbnQsIGI/OiBjb2RlYnVpbGQuQnVpbGRFbnZpcm9ubWVudCkge1xuICBpZiAoIWEgfHwgIWIpIHsgcmV0dXJuIGEgPz8gYjsgfVxuXG4gIHJldHVybiB7XG4gICAgYnVpbGRJbWFnZTogYi5idWlsZEltYWdlID8/IGEuYnVpbGRJbWFnZSxcbiAgICBjb21wdXRlVHlwZTogYi5jb21wdXRlVHlwZSA/PyBhLmNvbXB1dGVUeXBlLFxuICAgIGVudmlyb25tZW50VmFyaWFibGVzOiB7XG4gICAgICAuLi5hLmVudmlyb25tZW50VmFyaWFibGVzLFxuICAgICAgLi4uYi5lbnZpcm9ubWVudFZhcmlhYmxlcyxcbiAgICB9LFxuICAgIHByaXZpbGVnZWQ6IGIucHJpdmlsZWdlZCA/PyBhLnByaXZpbGVnZWQsXG4gIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUJ1aWxkU3BlY3MoYTogY29kZWJ1aWxkLkJ1aWxkU3BlYywgYj86IGNvZGVidWlsZC5CdWlsZFNwZWMpOiBjb2RlYnVpbGQuQnVpbGRTcGVjO1xuZXhwb3J0IGZ1bmN0aW9uIG1lcmdlQnVpbGRTcGVjcyhhOiBjb2RlYnVpbGQuQnVpbGRTcGVjIHwgdW5kZWZpbmVkLCBiOiBjb2RlYnVpbGQuQnVpbGRTcGVjKTogY29kZWJ1aWxkLkJ1aWxkU3BlYztcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUJ1aWxkU3BlY3MoYT86IGNvZGVidWlsZC5CdWlsZFNwZWMsIGI/OiBjb2RlYnVpbGQuQnVpbGRTcGVjKTogY29kZWJ1aWxkLkJ1aWxkU3BlYyB8IHVuZGVmaW5lZDtcbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUJ1aWxkU3BlY3MoYT86IGNvZGVidWlsZC5CdWlsZFNwZWMsIGI/OiBjb2RlYnVpbGQuQnVpbGRTcGVjKSB7XG4gIGlmICghYSB8fCAhYikgeyByZXR1cm4gYSA/PyBiOyB9XG4gIHJldHVybiBjb2RlYnVpbGQubWVyZ2VCdWlsZFNwZWNzKGEsIGIpO1xufVxuXG5mdW5jdGlvbiBpc0RlZmluZWQ8QT4oeDogQSB8IHVuZGVmaW5lZCk6IHggaXMgTm9uTnVsbGFibGU8QT4ge1xuICByZXR1cm4geCAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNoPEE+KG9iajogQSkge1xuICBjb25zdCBkID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpO1xuICBkLnVwZGF0ZShKU09OLnN0cmluZ2lmeShvYmopKTtcbiAgcmV0dXJuIGQuZGlnZXN0KCdoZXgnKTtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgYSBidWlsZCBlbnZpcm9ubWVudCB0byBkYXRhIChnZXQgcmlkIG9mIGNvbnN0cnVjdHMgJiBvYmplY3RzKSwgc28gd2UgY2FuIEpTT04uc3RyaW5naWZ5IGl0XG4gKi9cbmZ1bmN0aW9uIHNlcmlhbGl6ZUJ1aWxkRW52aXJvbm1lbnQoZW52OiBjb2RlYnVpbGQuQnVpbGRFbnZpcm9ubWVudCkge1xuICByZXR1cm4ge1xuICAgIHByaXZpbGVnZWQ6IGVudi5wcml2aWxlZ2VkLFxuICAgIGVudmlyb25tZW50VmFyaWFibGVzOiBlbnYuZW52aXJvbm1lbnRWYXJpYWJsZXMsXG4gICAgdHlwZTogZW52LmJ1aWxkSW1hZ2U/LnR5cGUsXG4gICAgaW1hZ2VJZDogZW52LmJ1aWxkSW1hZ2U/LmltYWdlSWQsXG4gICAgY29tcHV0ZVR5cGU6IGVudi5jb21wdXRlVHlwZSxcbiAgICBpbWFnZVB1bGxQcmluY2lwYWxUeXBlOiBlbnYuYnVpbGRJbWFnZT8uaW1hZ2VQdWxsUHJpbmNpcGFsVHlwZSxcbiAgICBzZWNyZXRzTWFuYWdlckFybjogZW52LmJ1aWxkSW1hZ2U/LnNlY3JldHNNYW5hZ2VyQ3JlZGVudGlhbHM/LnNlY3JldEFybixcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YWNrVmFyaWFibGVOYW1lc3BhY2Uoc3RhY2s6IFN0YWNrRGVwbG95bWVudCkge1xuICByZXR1cm4gc3RhY2suc3RhY2tBcnRpZmFjdElkO1xufVxuXG4vKipcbiAqIFdoZXRoZXIgdGhlIGdpdmVuIHN0cmluZyBjb250YWlucyBhIHJlZmVyZW5jZSB0byBhIENvZGVQaXBlbGluZSB2YXJpYWJsZVxuICovXG5mdW5jdGlvbiBjb250YWluc1BpcGVsaW5lVmFyaWFibGUoczogc3RyaW5nKSB7XG4gIHJldHVybiAhIXMubWF0Y2goLyNcXHtbXn1dK1xcfS8pO1xufVxuXG4vKipcbiAqIFR1cm4gYSBjb2xsZWN0aW9uIGludG8gYSBjb2xsZWN0aW9uIG9mIENvZGVQaXBlbGluZSBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAqL1xuZnVuY3Rpb24gY2JFbnYoeHM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD4pOiBSZWNvcmQ8c3RyaW5nLCBjb2RlYnVpbGQuQnVpbGRFbnZpcm9ubWVudFZhcmlhYmxlPiB7XG4gIHJldHVybiBta2RpY3QoT2JqZWN0LmVudHJpZXMoeHMpXG4gICAgLmZpbHRlcigoWywgdl0pID0+IHYgIT09IHVuZGVmaW5lZClcbiAgICAubWFwKChbaywgdl0pID0+IFtrLCB7IHZhbHVlOiB2IH1dIGFzIGNvbnN0KSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZWRBcnJheTxBPih4czogQVtdKTogQVtdIHwgdW5kZWZpbmVkIHtcbiAgcmV0dXJuIHhzLmxlbmd0aCA+IDAgPyB4cyA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBJZiBsaW5lcyBpbiB0aGUgYnVpbGRzcGVjIHN0YXJ0IHdpdGggJyFXSU5ET1dTIScgb3IgJyFMSU5VWCEnLCBvbmx5IHJlbmRlciB0aGVtIG9uIHRoYXQgcGxhdGZvcm0uXG4gKlxuICogVmVyeSBwcml2YXRlIHByb3RvY29sIGZvciBub3csIGJ1dCBtYXkgY29tZSBpbiBoYW5keSBpbiBvdGhlciBsaWJyYXJpZXMgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZmlsdGVyQnVpbGRTcGVjQ29tbWFuZHMoYnVpbGRTcGVjOiBjb2RlYnVpbGQuQnVpbGRTcGVjLCBvc1R5cGU6IGVjMi5PcGVyYXRpbmdTeXN0ZW1UeXBlKSB7XG4gIGlmICghYnVpbGRTcGVjLmlzSW1tZWRpYXRlKSB7IHJldHVybiBidWlsZFNwZWM7IH1cbiAgY29uc3Qgc3BlYyA9IChidWlsZFNwZWMgYXMgYW55KS5zcGVjO1xuXG4gIGNvbnN0IHdpblRhZyA9ICchV0lORE9XUyEnO1xuICBjb25zdCBsaW51eFRhZyA9ICchTElOVVghJztcbiAgY29uc3QgZXhwZWN0ZWRUYWcgPSBvc1R5cGUgPT09IGVjMi5PcGVyYXRpbmdTeXN0ZW1UeXBlLldJTkRPV1MgPyB3aW5UYWcgOiBsaW51eFRhZztcblxuICByZXR1cm4gY29kZWJ1aWxkLkJ1aWxkU3BlYy5mcm9tT2JqZWN0KHJlY3Vyc2Uoc3BlYykpO1xuXG4gIGZ1bmN0aW9uIHJlY3Vyc2UoeDogYW55KTogYW55IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgICAgY29uc3QgcmV0OiBhbnlbXSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBlbCBvZiB4KSB7XG4gICAgICAgIGNvbnN0IFt0YWcsIHBheWxvYWRdID0gZXh0cmFjdFRhZyhlbCk7XG4gICAgICAgIGlmICh0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgPT09IGV4cGVjdGVkVGFnKSB7XG4gICAgICAgICAgcmV0LnB1c2gocGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGlmICh4ICYmIHR5cGVvZiB4ID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIG1hcFZhbHVlcyh4LCByZWN1cnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHg7XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0VGFnKHg6IGFueSk6IFtzdHJpbmcgfCB1bmRlZmluZWQsIGFueV0ge1xuICAgIGlmICh0eXBlb2YgeCAhPT0gJ3N0cmluZycpIHsgcmV0dXJuIFt1bmRlZmluZWQsIHhdOyB9XG4gICAgZm9yIChjb25zdCB0YWcgb2YgW3dpblRhZywgbGludXhUYWddKSB7XG4gICAgICBpZiAoeC5zdGFydHNXaXRoKHRhZykpIHsgcmV0dXJuIFt0YWcsIHguc3Vic3RyKHRhZy5sZW5ndGgpXTsgfVxuICAgIH1cbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgeF07XG4gIH1cbn0iXX0=